[剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)
> 相同的数异或为0，不同的异或为1。0和任何数异或等于这个数本身。
  所以，数组里面所有数异或 = 目标两个数异或 。 由于这两个数不同，所以异或结果必然不为0。
  假设数组异或的二进制结果为10010，那么说明这两个数从右向左数第2位是不同的
  那么可以根据数组里面所有数的第二位为0或者1将数组划分为2个。
  这样做可以将目标数必然分散在不同的数组中，而且相同的数必然落在同一个数组中。
  这两个数组里面的数各自进行异或，得到的结果就是答案

```python
class Solution(object):
    def singleNumbers(self, nums):
        ret, index = 0, 0
        for n in nums:
            ret ^= n
        # 找从右向左数第几位不同，也就是第index位
        # 这一步其实可以根据n & (-n)的快捷方式获得，不过对位运算掌握不是那么熟练的话，记结论容易忘，不如理解实质
        while ret & 1 == 0:
            index += 1
            ret >>= 1
        r1, r2 = 0, 0
        for n in nums:
            if (n >> index) & 1 == 0:
                r1 ^= n
            else:
                r2 ^= n
        return [r1, r2]
```

# 运算符
## 1 与运算符(&)  

   如果  4&7   那么这个应该怎么运算呢？

     首先我们需要把两个十进制的数转换成二进制 

     4 ： 0000 0100

     7 ： 0000 0111

[![image](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204023318-896402392.png "image")](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204022745-1107563193.png)

在这里要提到一点，1表示true，0表示false

而与运算的时候相同位之间其实就是两个Boolean的运算

                     全true(1),即为true(1)

                     全false(0),即为false(0)

                     一false(0)一true(1),还是false(0)

## 2 或运算符(|)

   以   5|9   为例

   5 ： 0000 0101 

   9 ： 0000 1001

[![image](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204023839-746073083.png "image")](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204023575-1172288145.png)

在做与运算的时候

 **遇true(1)就是true(1),**

 **无true(1)就是false(0)**

## 5) 异或运算符(^)

 **以 7^15 为例**

 **7：   0000 0111**

 **15： 0000 1111**

[![image](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204024486-170768630.png "image")](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204024149-967390106.png)

在异或的时候

               只要相同都是false(0)

               只有不同才是true(1)

## 3 取反运算符(~)

        例：   ~15

        同样的先变成二进制：15：0000 1111

[![image](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204025095-66285937.png "image")](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204024870-227422826.png)

      这个其实挺简单的，就是把1变0，0变1

注意：二进制中，最高位是符号位   1表示负数，0表示正数

## 4 左移运算(<<)

     左移就是把所有位向左移动几位

 如：   12 << 2    意思就是12向左移动两位

 12的二进制是： 0000 1100

[![image](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204025593-1010819449.png "image")](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204025326-1518482974.png)

通过这个图我们可以看出来，所有的位全都向左移动两位，然后把右边空的两个位用0补上，最左边多出的两个位去掉，最后得到的结果就是00110000  结果就是48

**我们用同样的办法算 12<<3  结果是 96**

 **8<<4  结果是  128**

 **由此我们得出一个快速的算法    M << n   其实可以这么算   M << n  = M \* 2<sup>n</sup>**

## **5 右移运算符(>>)**

**这个跟左移运算大体是一样的**

 **例： 12 >> 2**

[![image](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204026288-104461375.png "image")](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204025862-1215072643.png)

**我们可以看出来右移和左移其实是一样的，但是还是有点不同的，不同点在于对于正数和负数补位的时候补的不一样，负数补1，正数补0**

**如我们再做一个 –8 的    -8>>2**

[**![image](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204026787-52956237.png "image")**](https://img2018.cnblogs.com/blog/1470032/201810/1470032-20181023204026563-746326181.png)

**这里总结一下，关于负数或者正数来说，移位的时候是一样的，但是在补位的时候，如果最高位是0就补0，如果最高位是1就补1**

**由此我们得出一个快速的算法    M >> n   其实可以这么算   M >> n  = M / 2^****n**

## 6 无符号右移(>>>)

  无符号右移(>>>)只对32位和64位有意义

在移动位的时候与右移运算符的移动方式一样的，区别只在于补位的时候不管是0还是1，都补0